#define OLC_PGE_APPLICATION
#include "olcPixelGameEngine.h"
#include <vector>
#include <string>
#define OLC_PGEX_TRANSFORMEDVIEW
#include "olcPGEX_TransformedView.h"
#include <Math.h>
#include <numbers>

/**
* Application controls:
*
* Both modes:
* @escape:
*   Toggle to other mode
*
* Edit mode:
*
* @1: place points with left click, pan with right click, auto create line segments, contribute to current polygon (DONE)
* @2: select nearest point to point with left click, drag originating within select point = move the point
*     (with affordance margin), pan with right click (DONE - reduced, always drag nearest poly - good enough)
* @3:
*  left click place the BALL at current mouse position, check if spawn is good, if no, move it to valid position, pan on right click 
*    (DONE - no spawn check - kinda funny to watch collision resolve on start if bad spawn)
* @back_space: delete the currently selected item (DONE)
* @4: left click place an EXIT at current mouse position, clicking on an EXIT makes it the selected item, pan on right click
*     (DONE - left click, move nearest portal to mouse pos, ENTER to create new portal at mouse pos - good enough)
* @enter:
*   enter while a point is selected 'confirms' the current polygon, subsequent points will belong to a new polygon
*     (DONE - also, pressing enter in portal mode creates a new exit portal)
* @5: Polygon select mode: If clicking within polygon, that polygon becomes the selected item
*       (NOT DONE - selects polygon with closest vertex to mouse pos. Not implemented: selecting vert in the selected poly for movement or deletion)
*     Allows delection of polygon.
*     Clicking outside of polygon clears current selected item
*       If a polygon is selected, pressing enter cycles the selected item to through the points in the polygon
*
* Design choices (for time expedience) Once a polygon is confirmed, it cannot be edited again, changes? It will have to be
* deleted and then recreated.
*
* Play mode:
* @a: add left spin to the ball (DONE)
* @d: add right spin to the ball (DONE)
* @space: vertical jump impulse on the ball (DONE)
* @back_space: restart level (DONE)
*/

/*
	Progress goals:
	- (DONE) Add the PGE extension for panning and zooming, integrate it into the application
          - https://www.youtube.com/watch?v=OqfHIujOvnE
	- (DONE) Draw state string to screen for visibility and explainability
          - editor: [[1]] place points [2] select and move points [3] place ball [4] place exits [5] select polygons [enter] confirm polygon [backspace] delete | selected item { ... }
          - play: [a] go left [d] go right [space] jump | [esc] back to editor | [backspace] restart | ball params { ... }
	- (DONE) Always Init with a basic test level
	  - achieve via play mode always writing some basic level geo to the application game state
	- (TODO) Implement Play mode
	- (DONE) Then implement the editor
        - (TODO) Stretch goals:
          - draw nearest selectable item with highlight, given input mode
          - control other shapes (Square, rectangle, pill shape, triangle, etc)
		  - draw animated graphic on goal
		  - draw star parallax background
*/

constexpr auto AequalsB = 0;
constexpr auto AisBigger = 1;
constexpr auto BisBigger = -1;
inline static int CompareFloat(const double a, const double b) {
	if (fabs(a - b) < DBL_EPSILON) return AequalsB;
	if (a < b) return BisBigger;
	return AisBigger;
}
constexpr auto m1 = 0;

namespace ngon {
	class Polygon {
	public:
		std::vector<olc::vd2d> points;
		Polygon() = default;
		Polygon(std::initializer_list<olc::vd2d> initialPoints) : points(initialPoints) {}
		int numbSegments() const {
			size_t numbPoints = points.size();
			if (numbPoints < 2) { return 0; }
			if (numbPoints == 2) { return 1; }
			return numbPoints;
		}
		double segmentLength(int segmentIdx) const {
			return std::sqrt(squaredSegmentLength(segmentIdx));
		}
		/**
		* Write the start and end point of a line segment to start and end respectively.
		* returns false if the requested line segment index does not exist in this polygon.
		*/
		bool getSegmentPoints(int segmentIdx, olc::vd2d& start, olc::vd2d& end) const {
			if (segmentIdx >= points.size()) { return false; }
			auto lastSegmentIdx = points.size() - 1;
			if (segmentIdx == lastSegmentIdx) {
				start = points[lastSegmentIdx];
				end = points[0];
			}
			else {
				start = points[segmentIdx];
				end = points[segmentIdx + 1];
			}
			return true;
		}
		double squaredSegmentLength(int segmentIdx) const {
			olc::vd2d start, end;
			if (!getSegmentPoints(segmentIdx, start, end)) { return 0.0; }
			return (end - start).mag2();
		}
		bool pointOnSegment(int segmentIdx, const olc::vd2d& point) const {
			// using the slope form of the line equation, substitute in the x value of the point into the equation
			// check if the y component of the point matches the y value generated by the line equation
			olc::vd2d start, end;
			if (!getSegmentPoints(segmentIdx, start, end)) { return false; }
			double gradient = (end.y - start.y) / (end.x - end.y);
			double c = start.y - (gradient * start.x);
			double expected = gradient * point.x + c;
			return CompareFloat(expected, point.y) == AequalsB;
		}
	};
	// TODO consider moving these to their own *.h and *.cpp files to clean up this file, instead of forward declaring
	/**
	* The player controls the ball in play mode
	*/
	class Ball {
	public:
		Ball() = default;
		Ball(olc::vd2d pos) : position(pos) { }
		olc::vd2d position;
		olc::vd2d velocity = {};
		olc::vd2d netForce = {};
		/**
		* rotational velocity in radians per second
		* +ve ang vel results in CCW rotation
		*/
		double angularVelocity = 0.0;
		/**
		* Total amount of rotation this ball has undergone.
		*/
		double angularDisplacement = 0.0;
		bool wantsToImpulse = false;
		double rScale = 1.0; // render scale
		/**
		* How 'bouncy' the ball is. Magic number for ball encountering elastic collisions.
		* Tells us what % of ball kinetic energy is maintained in a collision.
		*/
		static constexpr double elasticity = 0.4;
		static constexpr double radius = 0.5;
		static constexpr double mass = 5.0;
		static constexpr double frictionCoefficient = 0.8;
		static constexpr double dragCoefficient = 0.47;
		static constexpr double inertiaMoment = (2.0 / 5.0) * mass * radius * radius;
		bool pointInBall(const olc::vd2d& point) const {
			// make a line from ball origin to the point
			// point is in the ball if the length of the line is less than the radius
			olc::vd2d line = point - position;
			return line.mag2() < (radius * radius);
		}
		/**
		* Test if this ball intersects with a line segment.
		* Writes the vector from the [closest point on the line] to the ball origin to v.
		*/
		bool BallLineIntersect(const olc::vd2d& start, const olc::vd2d& end, olc::vd2d& v) const {
			olc::vd2d endStart = end - start;
			double t = (position - start).dot(endStart) / endStart.dot(endStart);
			olc::vd2d closest; 
			if (t < 0.0) {
				closest = start;
			} else if (t > 1.0) {
				closest = end;
			} else {
				closest = start + endStart * t;
			}
			olc::vd2d lineToBall = position - closest; // TODO are these the right way around?
			v = lineToBall;
			double distanceSquared = lineToBall.mag2();
			return distanceSquared < (radius * radius);
		}
	};
	class Goal {
	public:
		Goal() = default;
		Goal(olc::vd2d pos) : position(pos) { }
		olc::vd2d position;
		static constexpr double radius = 0.5;
		bool GoalBallOverlap(const Ball& ball) const {
			// if the distance between the ball and the goal is less than their two radii combined, then they have overlapped
			return (position - ball.position).mag2() < ((radius * radius) + (ball.radius * ball.radius));
		}
	};
	struct GameState {
		// Ngon is built from points. These points are connected to form a line segment
		// The line segments all connect to form the polygon
		std::vector<ngon::Polygon> shapes;
		std::vector<ngon::Goal> goals;
		ngon::Ball ball;
		ngon::Goal* attractor;
	};
	class ApplicationState;
	class Editing;
}

// Override base class with your custom functionality
class NgonPuzzle : public olc::PixelGameEngine
{
public:
	NgonPuzzle();

	ngon::GameState state;
	ngon::Editing* editing;
	ngon::ApplicationState* applicationState;
	olc::TransformedView view;
	bool drawGameState = true;


public:
	bool OnUserCreate() override;
	bool OnUserUpdate(float fElapsedTime) override;
};

namespace ngon {

	static std::string StringFromGameState(GameState* state) {
		if (state == nullptr) {
			return "";
		}
		auto& b = state->ball;
		return std::format("Ball properties [\n\tpos {},\n\tvel {},\n\tangVel {},\n\twantToJump {},\n\tnetForce {}\n]",
			b.position.str(),
			b.velocity.str(),
			b.angularVelocity,
			b.wantsToImpulse,
			b.netForce.str()
		);
	}

	class ApplicationState {
	public:
		NgonPuzzle* app;
		ApplicationState(NgonPuzzle* app) : app(app) { }
		/**
		* Application tick
		*/
		virtual bool OnUserUpdate(float fElapsedTime) = 0;
		/**
		* The first tick while this state is alive. Perform any clean up/set up before subsequent ticks.
		*/
		virtual void OnStateStart() = 0;
		virtual std::string GetStateString() = 0;
	};

	class Editing : public ApplicationState {
	protected:
		struct Selected {
			olc::vd2d* vertex;
			Goal* goal;
			const Polygon* polygon;
		};
		Selected selected = {
			nullptr, nullptr, nullptr
		};
	public:
		Editing(NgonPuzzle* app) : ApplicationState(app) {
			// initial level
			memento = ngon::GameState{
				{
					ngon::Polygon({ {0,0},{3,0},{4,1},{5,0},{7,0},{7,1},{8,1},{8,-3},{-2,-3},{-1,1} }),
				},
				{
					ngon::Goal({6.2, 0.5}),
				},
				ngon::Ball({0, 1.7}),
				nullptr
			};
		}
		ngon::GameState memento;
		enum EditState {
			placingPoints,
			movePoints,
			placeBall,
			placeExit,
			polygonSelect,
		};
		EditState editState = placingPoints;
		// currently selected item
		// editor state: placing | selecting points | placing ball | placing exits | polygon selecting | 
	public:
		void OnStateStart() override {
			// restore state to how it was before gameplay started
			app->state = memento;
			selected = {nullptr, nullptr, nullptr}; // reset selected items
		}
		bool OnUserUpdate(float fElapsedTime) override {
			bool editMade = false;
			app->view.HandlePanAndZoom(); // not sure how to update to mouse 2 instead of middle mouse button
			const auto mousePosInWorld = app->view.ScreenToWorld(app->GetMousePos());
			if (app->GetKey(olc::Key::K1).bPressed) {
				this->editState = placingPoints;
				this->selected.vertex = nullptr;
			}
			if (app->GetKey(olc::Key::K2).bPressed) {
				this->editState = movePoints;
				this->selected.vertex = nullptr;
			}
			if (app->GetKey(olc::Key::K3).bPressed) {
				this->editState = placeBall;
			}
			if (app->GetKey(olc::Key::K4).bPressed) {
				this->editState = placeExit;
				this->selected.goal = nullptr;
			}
			if (app->GetKey(olc::Key::K5).bPressed) {
				this->editState = polygonSelect;
				this->selected.polygon = nullptr;
			}
			if (app->GetKey(olc::Key::ENTER).bPressed) {
				this->selected.polygon = nullptr;
				this->selected.vertex = nullptr;
				this->selected.goal = nullptr;
				if (editState == EditState::placingPoints &&
					!this->app->state.shapes.back().points.empty()) {
					editMade = true;
					this->app->state.shapes.push_back(Polygon());
				}
				if (editState == EditState::placeExit) {
					editMade = true;
					this->app->state.goals.push_back(Goal(mousePosInWorld));
				}
			}
			if (app->GetKey(olc::Key::BACK).bPressed) {
				if (editState == EditState::polygonSelect && this->selected.polygon != nullptr) {
					for (auto iterator = app->state.shapes.begin(); 
						  iterator != app->state.shapes.end(); iterator++) {
						if (&(*iterator) == selected.polygon) {
							app->state.shapes.erase(iterator);
							this->selected.polygon = nullptr;
							this->selected.vertex = nullptr;
							editMade = true;
							break;
						}
					}
					if (app->state.shapes.empty()) {
						app->state.shapes.push_back(Polygon());
					}
				}
				if (editState == EditState::movePoints && this->selected.vertex != nullptr) {
					for (auto iterator = app->state.shapes.back().points.begin();
							iterator != app->state.shapes.back().points.end(); iterator++) {
						if (&(*iterator) == selected.vertex) {
							app->state.shapes.back().points.erase(iterator);
							this->selected.vertex = nullptr;
							editMade = true;
							break;
						}
					}
				}
				if (editState == EditState::placeExit && selected.goal != nullptr) {
					for (auto iterator = app->state.goals.begin();
						iterator != app->state.goals.end(); iterator++) {
						if (&(*iterator) == selected.goal) {
							app->state.goals.erase(iterator);
							this->selected.goal = nullptr;
							editMade = true;
							break;
						}
					}
				}
				if (editState == EditState::placingPoints) {
					// delete the last vert in the currently edited shape
					if (!this->app->state.shapes.back().points.empty()) {
						this->selected.polygon = nullptr;
						this->selected.vertex = nullptr;
						this->app->state.shapes.back().points.pop_back();
						editMade = true;
					}
				}
				
			}
			// yeah yeah, I know, we should use the State design pattern here. maybe later.
			// TODO refactor out these for loops, we're copy pasting the same for loop multiple times
			if (app->GetMouse(m1).bPressed) {
				double closestSq = std::numeric_limits<double>::infinity();
				if (this->editState == placingPoints) {
					editMade = true;
					app->state.shapes.back().points.push_back(mousePosInWorld);
				}
				if (this->editState == EditState::movePoints) {
					for (olc::vd2d& p : app->state.shapes.back().points) {
						double dist = (p - mousePosInWorld).mag2();
						if (dist < closestSq) {
							closestSq = dist;
							selected.vertex = &p;
						}
					}
				}
				if (this->editState == EditState::placeExit) {
					for (Goal& goal : app->state.goals) {
						double dist = (goal.position - mousePosInWorld).mag2();
						if (dist < closestSq) {
							closestSq = dist;
							selected.goal = &goal;
						}
					}
				}
				if (this->editState == EditState::polygonSelect) {
					// There are two ways we could do this
					// [ ] 1: select poly whose 'center of mass' is closest to the mouse pos
					// [x] 2: select poly that has the vertex which is closest to the mouse pos
					for (const Polygon& poly : app->state.shapes) {
						for (const olc::vd2d& p : poly.points) {
							double dist = (p - mousePosInWorld).mag2();
							if (dist < closestSq) {
								closestSq = dist;
								selected.polygon = &poly;
							}
						}
					}
				}
			} else if (app->GetMouse(m1).bHeld) {
				if (editState == EditState::placeBall) {
					editMade = true;
					app->state.ball.position = mousePosInWorld;
				}
				if (editState == EditState::movePoints && selected.vertex != nullptr) {
					editMade = true;
					selected.vertex->x = mousePosInWorld.x;
					selected.vertex->y = mousePosInWorld.y;
				}
				if (editState == EditState::placeExit && selected.goal != nullptr) {
					editMade = true;
					selected.goal->position.x = mousePosInWorld.x;
					selected.goal->position.y = mousePosInWorld.y;
				}
			}else if (app->GetMouse(m1).bReleased) {

			}
			// Update the memento
			if (editMade)
				this->memento = app->state;
			return true;
		}
		std::string GetStateString() override {
			std::string one = editState == placingPoints ? "[[1]]" : " [1] "; // D.R.Y. believers in disbelief right now - coping
			std::string two = editState == movePoints ? "[[2]]" : " [2] ";
			std::string three = editState == placeBall ? "[[3]]" : " [3] ";
			std::string four = editState == placeExit ? "[[4]]" : " [4] ";
			std::string five = editState == polygonSelect ? "[[5]]" : " [5] ";
			std::string enter = 
				editState == placingPoints ? "make new polygon" : 
				editState == placeExit ? "make new portal" : 
				"_";
			std::string backspace = 
				editState == placingPoints ? "delete last vertex" :
				editState == movePoints ? "_" :
				editState == placeBall ? "_" :
				editState == placeExit ? "delete selected portal" :
				editState == polygonSelect ? "delete selected polygon" :
				"";
			std::string lmb = 
				editState == placingPoints ? "add vert to poly" :
				editState == movePoints ? "select/move vert" :
				editState == placeBall ? "move ball" :
				editState == placeExit ? "place exit" :
				editState == polygonSelect ? "select vert group" :
				"_"
			;

			return std::format(
				"Controls:\n{} place points {} move points {} place ball\n{} place exit {} select polygon\n[enter] {} [backspace] {}\n" \
				"[MMB] pan [ScrWhl] zoom [LMB] {}\n[esc] play level",
				one, two, three, four, five, enter, backspace, lmb
			);
		}

	};

	class Playing : public ApplicationState {
	public:
		Playing(NgonPuzzle* app) : ApplicationState(app) {
		}
		enum PlayState {
			paused,
			live,
			victory_anim_seq,
			victory_end,
		};
		std::string PlayStateToString(PlayState state) {
			switch (state) {
			case live:
				return "Live";
			case paused: 
				return "Paused";
			case victory_anim_seq:
				return "Victory";
			case victory_end:
				return "You won";
			default:
				return "Unknown";
			}
		}
		PlayState playState = live;
		void OnStateStart() override {
			playState = live;
		}
		bool OnUserUpdate(float fElapsedTime) override {
			if (app->GetKey(olc::Key::BACK).bPressed) {
				app->state = app->editing->memento;
				this->playState = PlayState::live;
			}
			// Set the view to center on the ball position
			ngon::Ball& ball = this->app->state.ball;
			olc::vd2d ballWorldPos = ball.position;
			app->view.SetWorldOffset(
				ballWorldPos - app->GetScreenSize() / 2 / app->view.GetWorldScale()
			);
			// handle user input
			if (this->playState == live) {
				auto angularAcceleration = 2.0 * std::numbers::pi;
				if (app->GetKey(olc::Key::A).bHeld) {
					app->state.ball.angularVelocity += angularAcceleration * fElapsedTime;
				}
				if (app->GetKey(olc::Key::D).bHeld) {
					app->state.ball.angularVelocity -= angularAcceleration * fElapsedTime;
				}
				if (app->GetKey(olc::Key::SPACE).bPressed) {
					ball.wantsToImpulse = true;
				}
				tickBall(app->state.ball, fElapsedTime);
			}
			for (Goal& goal : app->state.goals) {
				tickGoal(goal, fElapsedTime);
			}
			if (playState == PlayState::victory_end) {
				// TODO draw on top, text currently hidden behind level geometry
				app->DrawString(app->GetScreenSize() / 2, "You won!\nPress backspace to restart\nPress Esc to return to editor.");
			}
			return true;
		}
		std::string GetStateString() override {
			return std::format("Playing: {}\n[A] roll left [D] roll right\n[ESC] open editor [backspace] restart", PlayStateToString(this->playState));
		}
		// putting the tick here so the ball and goal don't need a reference back to the state
		void tickBall(Ball& ball, float fElapsedTime) {
			ball.netForce = {0,0};
			/* 
			TODO in the future this could be sped up in various ways
			Each polygon can be enveloped in a bounding sphere, check for sphere overlap 
			before checking the line segments
			Bounding circles can be stored in a spatial acceleration datastructure like a 
			quad tree or K-d tree to discard far away polygons early.
			*/
			for (const Polygon& poly : app->state.shapes) {
				for (int idx = 0; idx < poly.numbSegments(); idx++) {
					olc::vd2d collisionNormal = {};
					olc::vd2d start, end;
					poly.getSegmentPoints(idx, start, end);
					if (!ball.BallLineIntersect(start, end, collisionNormal)) { 
						continue;
					}
					olc::vd2d normalizedCollisionNormal = collisionNormal.norm();
					/* LLM GENERATED CODE */ // Something to get started, still not working correctly - TODO will need re-write
					auto relativeVelocity = ball.velocity.dot(normalizedCollisionNormal);
					if (relativeVelocity > 0.0) {
						// Ball is moving away from the line segment.
						continue;
					}
					// apply force from collision
					auto tangent = olc::vd2d{-normalizedCollisionNormal.y, normalizedCollisionNormal.x};
					auto normalVelocity = relativeVelocity * normalizedCollisionNormal;
					auto tangentVelocity = ball.velocity.dot(tangent) * tangent;
					auto contactPoint = ball.position + normalizedCollisionNormal * ball.radius;
					auto r = ball.radius * normalizedCollisionNormal;
					auto rotationalVelocity = olc::vd2d{
						-ball.angularVelocity * r.y,
						ball.angularVelocity * r.x
					};
					auto contactVelocity = ball.velocity + rotationalVelocity;
					auto contactVelocityNormal = contactVelocity.dot(normalizedCollisionNormal) * normalizedCollisionNormal;
					auto contactVelocityTangent = contactVelocity.dot(tangent) * tangent;
					auto normalImpulse = 
						-(1.0 + ball.elasticity) * contactVelocity.dot(normalizedCollisionNormal) * ball.mass;
					normalImpulse = normalImpulse / (1.0 / ball.mass + ((ball.radius * ball.radius) / ball.inertiaMoment));

					auto tangentImpulseMax = ball.frictionCoefficient * std::abs(normalImpulse);
					auto tangentImpulse = -contactVelocity.dot(tangent) * ball.mass;
					tangentImpulse = tangentImpulse / (1.0 / ball.mass + ((ball.radius * ball.radius) / ball.inertiaMoment));
					tangentImpulse = std::clamp(tangentImpulse, -tangentImpulseMax, tangentImpulseMax);

					auto impulse = normalImpulse * normalizedCollisionNormal + tangentImpulse * tangent;

					ball.velocity += fElapsedTime * (impulse / ball.mass);

					auto torque = r.x * impulse.y - r.y * impulse.x;
					ball.angularVelocity += fElapsedTime * (torque / ball.inertiaMoment);
					/* END OF LLM CODE */

					if (ball.wantsToImpulse) {
						// user pressed space bar to jump
						// later, update this to be along the collision normal?
						// later, jump cool down timer?
						ball.velocity += olc::vd2d{0,5};
						ball.wantsToImpulse = false;
					}
					// Finally, move the ball to resolve the collision
					ball.position += (ball.radius - collisionNormal.mag()) * normalizedCollisionNormal;
				}
			}
			// update angular displacement, velocity
			ball.angularDisplacement += ball.angularVelocity * fElapsedTime;
			// force due to gravity
			ball.netForce += olc::vd2d{ 0, ball.mass * -3};
			// force from drag
			ball.netForce += ball.dragCoefficient * (ball.velocity * ball.velocity) * (0.5 * 4.0 * std::numbers::pi * ball.radius * ball.radius);
			// update velocity
			olc::vd2d netAcceleration = ball.netForce / ball.mass;
			ball.velocity += netAcceleration * fElapsedTime;

			ball.position += ball.velocity * fElapsedTime;
			// If ball is rubbing on a surface, use friction to convert some angular angual velocity into tangential velocity
			ball.wantsToImpulse = false;
		}

		void tickGoal(Goal& goal, const float fElapsedTime) {
			if (this->playState == live && goal.GoalBallOverlap(app->state.ball)) {
				this->playState = victory_anim_seq;
				this->app->state.attractor = &goal;
			} else if (playState == victory_anim_seq && app->state.attractor == &goal) {
				constexpr double ballSpeed = 0.4;
				constexpr double smallEnough = 0.01;
				Ball& ball = app->state.ball;
				olc::vd2d nextPos = ball.position.lerp(goal.position, 1.0 - ball.rScale);
				ball.rScale -= ballSpeed * fElapsedTime;
				ball.position = nextPos;
				if (app->state.ball.rScale < smallEnough) {
					this->playState = victory_end;
				}
			}
			// TODO animated over time properties can be updated here
		}
	};
}

NgonPuzzle::NgonPuzzle() { sAppName = "Ngon puzzle builder"; }

bool NgonPuzzle::OnUserUpdate(float fElapsedTime) {
	// Clear Screen
	PixelGameEngine::Clear(olc::BLACK);
	// Handle user input
	if (PixelGameEngine::GetKey(olc::Key::ESCAPE).bReleased) {
		if (applicationState == editing) {
			applicationState = new ngon::Playing(this);
		}
		else {
			delete applicationState;
			applicationState = editing;
		}
		applicationState->OnStateStart();
	}
	if (PixelGameEngine::GetKey(olc::Key::EQUALS).bReleased) {
		drawGameState = !drawGameState;
	}
	// handle panning
	applicationState->OnUserUpdate(fElapsedTime);
	// Draw
	// stars background TODO stretch goal
	
	// Status info
	std::string stStr = applicationState->GetStateString();
	int vertOffset = (int) std::count(stStr.begin(), stStr.end(), '\n');
	PixelGameEngine::DrawString({ 0,0 }, stStr);
	if (this->drawGameState) {
		PixelGameEngine::DrawString({ 0, 10 + (vertOffset * 10) }, ngon::StringFromGameState(&this->state));
	}
	// Polygons
	for (const auto &poly : this->state.shapes) {
		const size_t numbPoints = poly.points.size();
		if (numbPoints < 2) {
			continue;
		}
		olc::vf2d start = poly.points[0];
		olc::vf2d end = poly.points[numbPoints - 1];
		view.DrawLineDecal(start, end, olc::WHITE);
		for (size_t idx = 0; idx < numbPoints - 1; idx++) {
			olc::vf2d start = poly.points[idx];
			olc::vf2d end = poly.points[idx + 1];
			view.DrawLineDecal(start, end, olc::WHITE);
		}
	}
	// Ball
	view.DrawCircle(state.ball.position, state.ball.rScale * state.ball.radius, olc::WHITE);
	const auto m = state.ball.rScale * state.ball.radius * 0.6;
	olc::vd2d miniPos = {
		m * cos(state.ball.angularDisplacement),
		m * sin(state.ball.angularDisplacement)
	};
	view.DrawCircle(miniPos + state.ball.position, state.ball.rScale * state.ball.radius * 0.20, olc::WHITE);
	// Goals
	// TODO make the goals look cooler with some animated property that changes over time
	for (const ngon::Goal& goal : state.goals) {
		view.DrawCircle(goal.position, goal.radius, olc::DARK_MAGENTA);
	}
	return true;
}

bool NgonPuzzle::OnUserCreate() {
	// Called once at the start, so create things here

	view.Initialise(GetScreenSize());
	olc::vi2d viewArea(GetScreenSize());
	viewArea.x = -viewArea.x / 2.0;
	viewArea.y = viewArea.y / 2.0;
	view.SetWorldOffset(viewArea);
	view.SetWorldScale({1,-1});
	// TODO help wanted - zoom in. Initial zoom is insufficient.

	editing = new ngon::Editing(this);
	applicationState = editing;
	applicationState->OnStateStart();
	return true;
}

int main()
{
	NgonPuzzle demo;
	if (demo.Construct(640, 480, 2, 2))
		demo.Start();
	return 0;
}

// VS2022, see func overloads? CTRL + Shift + space
