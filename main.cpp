#define OLC_PGE_APPLICATION
#include "olcPixelGameEngine.h"
#include <vector>
#include <string>
#define OLC_PGEX_TRANSFORMEDVIEW
#include "olcPGEX_TransformedView.h"
#include <Math.h>
#include <numbers>

/**
* Application controls:
*
* Both modes:
* @escape:
*   Toggle to other mode
*
* Edit mode:
*
* @1: place points with left click, pan with right click, auto create line segments, contribute to current polygon
* @2: select nearest point to point with left click, drag originating within select point = move the point
*     (with affordance margin), pan with right click
* @3:
*  left click place the BALL at current mouse position, check if spawn is good, if no, move it to valid position, pan on right click
* @back_space: delete the currently selected item
* @4: left click place an EXIT at current mouse position, clicking on an EXIT makes it the selected item, pan on right click
* @enter:
*   enter while a point is selected 'confirms' the current polygon, subsequent points will belong to a new polygon
* @5: Polygon select mode: If clicking within polygon, that polygon becomes the selected item
*     Allows delection of polygon.
*     Clicking outside of polygon clears current selected item
*       If a polygon is selected, pressing enter cycles the selected item to through the points in the polygon
*
* Design choices (for time expedience) Once a polygon is confirmed, it cannot be edited again, changes? It will have to be
* deleted and then recreated.
*
* Play mode:
* @a: add left spin to the ball
* @d: add right spin to the ball
* @space: vertical jump impulse on the ball
* @back_space: restart level
*/

/*
	Progress goals:
	- (DONE) Add the PGE extension for panning and zooming, integrate it into the application
          - https://www.youtube.com/watch?v=OqfHIujOvnE
	- (TODO) Draw state string to screen for visibility and explainability
          - editor: [[1]] place points [2] select and move points [3] place ball [4] place exits [5] select polygons [enter] confirm polygon [backspace] delete | selected item { ... }
          - play: [a] go left [d] go right [space] jump | [esc] back to editor | [backspace] restart | ball params { ... }
	- (DONE) Always Init with a basic test level
	  - achieve via play mode always writing some basic level geo to the application game state
	- (TODO) Implement Play mode
	- (TODO) Then implement the editor
        - (TODO) Stretch goals:
          - draw nearest selectable item with highlight, given input mode
          - control other shapes (Square, rectangle, pill shape, triangle, etc)
*/

constexpr auto AequalsB = 0;
constexpr auto AisBigger = 1;
constexpr auto BisBigger = -1;
inline static int CompareFloat(const double a, const double b) {
	if (fabs(a - b) < DBL_EPSILON) return AequalsB;
	if (a < b) return BisBigger;
	return AisBigger;
}

namespace ngon {
	class Selectable {

	};
	class Polygon {
	public:
		std::vector<olc::vd2d> points;
		Polygon() = default;
		Polygon(std::initializer_list<olc::vd2d> initialPoints) : points(initialPoints) {}
		int numbSegments() const {
			size_t numbPoints = points.size();
			if (numbPoints < 2) { return 0; }
			if (numbPoints == 2) { return 1; }
			return numbPoints;
		}
		double segmentLength(int segmentIdx) const {
			return std::sqrt(squaredSegmentLength(segmentIdx));
		}
		/**
		* Write the start and end point of a line segment to start and end respectively.
		* returns false if the requested line segment index does not exist in this polygon.
		*/
		bool getSegmentPoints(int segmentIdx, olc::vd2d& start, olc::vd2d& end) const {
			if (segmentIdx >= points.size()) { return false; }
			auto lastSegmentIdx = points.size() - 1;
			if (segmentIdx == lastSegmentIdx) {
				start = points[lastSegmentIdx];
				end = points[0];
			}
			else {
				start = points[segmentIdx];
				end = points[segmentIdx + 1];
			}
			return true;
		}
		double squaredSegmentLength(int segmentIdx) const {
			olc::vd2d start, end;
			if (!getSegmentPoints(segmentIdx, start, end)) { return 0.0; }
			return (end - start).mag2();
		}
		bool pointOnSegment(int segmentIdx, const olc::vd2d& point) const {
			// using the slope form of the line equation, substitute in the x value of the point into the equation
			// check if the y component of the point matches the y value generated by the line equation
			olc::vd2d start, end;
			if (!getSegmentPoints(segmentIdx, start, end)) { return false; }
			double gradient = (end.y - start.y) / (end.x - end.y);
			double c = start.y - (gradient * start.x);
			double expected = gradient * point.x + c;
			return CompareFloat(expected, point.y) == AequalsB;
		}
	};
	// TODO consider moving these to their own *.h and *.cpp files to clean up this file, instead of forward declaring
	/**
	* The player controls the ball in play mode
	*/
	class Ball {
	public:
		Ball() = default;
		Ball(olc::vd2d pos) : position(pos) { }
		olc::vd2d position;
		olc::vd2d velocity = {};
		olc::vd2d netForce = {};
		/**
		* rotational velocity in radians per second
		* +ve ang vel results in CCW rotation
		*/
		double angularVelocity = 0.0;
		/**
		* Total amount of rotation this ball has undergone.
		*/
		double angularDisplacement = 0.0;
		bool wantsToImpulse = false;
		/**
		* How 'bouncy' the ball is. Magic number for ball encountering elastic collisions.
		* Tells us what % of ball kinetic energy is maintained in a collision.
		*/
		static constexpr double elasticity = 0.4;
		static constexpr double radius = 0.5;
		static constexpr double mass = 5.0;
		static constexpr double frictionCoefficient = 0.8;
		static constexpr double dragCoefficient = 0.47;
		static constexpr double inertiaMoment = (2.0 / 5.0) * mass * radius * radius;
		bool pointInBall(const olc::vd2d& point) const {
			// make a line from ball origin to the point
			// point is in the ball if the length of the line is less than the radius
			olc::vd2d line = point - position;
			return line.mag2() < (radius * radius);
		}
		/**
		* Test if this ball intersects with a line segment.
		* Writes the vector from the [closest point on the line] to the ball origin to v.
		*/
		bool BallLineIntersect(const olc::vd2d& start, const olc::vd2d& end, olc::vd2d& v) const {
			olc::vd2d endStart = end - start;
			double t = (position - start).dot(endStart) / endStart.dot(endStart);
			if (t < 0.0 || t > 1.0) {
				return false;
			}
			olc::vd2d closest = start + endStart * t;
			olc::vd2d lineToBall = position - closest; // TODO are these the right way around?
			v = lineToBall;
			double distanceSquared = lineToBall.mag2();
			return distanceSquared < (radius * radius);
		}
	};
	class Goal {
	public:
		Goal() = default;
		Goal(olc::vd2d pos) : position(pos) { }
		// If the Ball overlaps the Goal then play a simple animation:
		// scale the ball down overtime, and sinusoidal motion rotate it around the goal
		// slowly lerp ball position to goal middle
		olc::vd2d position;
		static constexpr double radius = 0.5;
		bool GoalBallOverlap(const Ball& ball) const {
			// if the distance between the ball and the goal is less than their two radii combined, then they have overlapped
			return (position - ball.position).mag2() < ((radius * radius) + (ball.radius * ball.radius));
		}
	};
	struct GameState {
		// Ngon is built from points. These points are connected to form a line segment
		// The line segments all connect to form the polygon
		std::vector<ngon::Polygon> shapes;
		std::vector<ngon::Goal> goals;
		ngon::Ball ball;
	};
	class ApplicationState;
	class Editing;
}

// Override base class with your custom functionality
class NgonPuzzle : public olc::PixelGameEngine
{
public:
	NgonPuzzle();

	ngon::GameState state;
	ngon::Editing* editing;
	ngon::ApplicationState* applicationState;
	olc::TransformedView view;


public:
	bool OnUserCreate() override;
	bool OnUserUpdate(float fElapsedTime) override;
};

namespace ngon {

	static std::string StringFromGameState(GameState* state) {
		if (state == nullptr) {
			return "";
		}
		auto& b = state->ball;
		return std::format("Ball properties [\n\tpos {},\n\tvel {},\n\tangVel {},\n\twantToJump {},\n\tnetForce {}]",
			b.position.str(),
			b.velocity.str(),
			b.angularVelocity,
			b.wantsToImpulse,
			b.netForce.str()
		);
	}

	class ApplicationState {
	public:
		NgonPuzzle* app;
		ApplicationState(NgonPuzzle* app) : app(app) { }
		/**
		* Application tick
		*/
		virtual bool OnUserUpdate(float fElapsedTime) = 0;
		/**
		* The first tick while this state is alive. Perform any clean up/set up before subsequent ticks.
		*/
		virtual void OnStateStart() = 0;
		virtual std::string GetStateString() = 0;
	};

	class Editing : public ApplicationState {
	public:
		Editing(NgonPuzzle* app) : ApplicationState(app) {

		}
		/**
		* OnStartEditing => make a new ball at this position
		*/
		olc::v_2d<double> ballPosition;
		// currently selected item
		// editor state: placing | selecting points | placing ball | placing exits | polygon selecting | 
	public:
		void OnStateStart() override {
		}
		bool OnUserUpdate(float fElapsedTime) override {
			app->view.HandlePanAndZoom(); // not sure how to update to mouse 2 instead of middle mouse button
			return true;
		}
		std::string GetStateString() override {
			return "editing: under construction";
		}

	};

	class Playing : public ApplicationState {
	public:
		Playing(NgonPuzzle* app) : ApplicationState(app) {
		}
		void OnStateStart() override {
			// TEMP
			// Write test level data to the application
			// Later on, all we would do is nothing. Just start ticking straight away
			this->app->state = ngon::GameState {
				{ 
					ngon::Polygon({ {0,0},{3,0},{4,1},{5,0},{7,0},{7,1},{8,1},{8,-3},{-2,-3},{-1,1} }),
				},
				{ 
					ngon::Goal({6.2, 0.5}),
				},
				ngon::Ball({0, 1.7})
			};
		}
		bool OnUserUpdate(float fElapsedTime) override {
			// Set the view to center on the ball position
			ngon::Ball& ball = this->app->state.ball;
			olc::vd2d ballWorldPos = ball.position;
			app->view.SetWorldOffset(
				ballWorldPos - olc::vd2d{ app->ScreenWidth() * 0.5, app->ScreenHeight() * 0.5} / 
				app->view.GetWorldScale()
			);
			// handle user input
			auto angularAcceleration = 2.0 * std::numbers::pi;
			if (app->GetKey(olc::Key::A).bHeld) {
				app->state.ball.angularVelocity += angularAcceleration * fElapsedTime;
			}
			if (app->GetKey(olc::Key::D).bHeld) {
				app->state.ball.angularVelocity -= angularAcceleration * fElapsedTime;
			}
			if (app->GetKey(olc::Key::SPACE).bPressed) {
				ball.wantsToImpulse = true;
			}
			// run simulation
			tickBall(app->state.ball, fElapsedTime);
			for (const Goal& goal : app->state.goals) {
				tickGoal(goal, fElapsedTime);
			}

			return true;
		}
		std::string GetStateString() override {
			return "playing: under construction";
		}
		// putting the tick here so the ball and goal don't need a reference back to the state
		void tickBall(Ball& ball, float fElapsedTime) {
			ball.netForce = {0,0};
			// TODO resolve static collision with polygons
			/* 
			TODO in the future this could be sped up in various ways
			Each polygon can be enveloped in a bounding sphere, check for sphere overlap 
			before checking the line segments
			Bounding circles can be stored in a spatial acceleration datastructure like a 
			quad tree or K-d tree to discard far away polygons early.
			*/
			for (const Polygon& poly : app->state.shapes) {
				for (int idx = 0; idx < poly.numbSegments(); idx++) {
					olc::vd2d collisionNormal = {};
					olc::vd2d start, end;
					poly.getSegmentPoints(idx, start, end);
					if (!ball.BallLineIntersect(start, end, collisionNormal)) { 
						continue;
					}
					if (ball.wantsToImpulse) {
						// user pressed space bar to jump
						// later, update this to be along the collision normal?
						// later, jump cool down timer?
						ball.velocity += olc::vd2d{0,5};
						ball.wantsToImpulse = false;
					}
					olc::vd2d normilizedCollisionNormal = collisionNormal.norm();
					olc::vd2d segment = end - start;
					// Finally, move the ball to resolve the collision
					ball.position += (ball.radius - collisionNormal.mag()) * normilizedCollisionNormal;
				}
			}
			// update angular displacement, velocity
			ball.angularDisplacement += ball.angularVelocity * fElapsedTime;
			// force due to gravity
			ball.netForce += olc::vd2d{ 0, ball.mass * -3};
			// force from drag
			ball.netForce += ball.dragCoefficient * (ball.velocity * ball.velocity) * (0.5 * 4.0 * std::numbers::pi * ball.radius * ball.radius);
			// update velocity
			olc::vd2d netAcceleration = ball.netForce / ball.mass;
			ball.velocity += netAcceleration * fElapsedTime;

			ball.position += ball.velocity * fElapsedTime;
			// If ball is rubbing on a surface, use friction to convert some angular angual velocity into tangential velocity
			ball.wantsToImpulse = false;
		}

		void tickGoal(const Goal& goal, float fElapsedTime) const {
			if (goal.GoalBallOverlap(app->state.ball)) {
				// TODO you win!
			}
			// TODO animated over time properties can be updated here
		}
	};
}

NgonPuzzle::NgonPuzzle() { sAppName = "Ngon puzzle builder"; }

bool NgonPuzzle::OnUserUpdate(float fElapsedTime) {
	// Clear Screen
	PixelGameEngine::Clear(olc::BLACK);
	// Handle user input
	if (PixelGameEngine::GetKey(olc::Key::ESCAPE).bReleased) {
		if (applicationState == editing) {
			applicationState = new ngon::Playing(this);
		}
		else {
			delete applicationState;
			applicationState = editing;
		}
		applicationState->OnStateStart();
	}
	// handle panning
	applicationState->OnUserUpdate(fElapsedTime);
	// Draw
	// stars background TODO stretch goal
	
	// Status info
	PixelGameEngine::DrawString({ 0,0 }, applicationState->GetStateString());
	PixelGameEngine::DrawString({ 0,10 }, ngon::StringFromGameState(&this->state));
	// Polygons
	for (const auto &poly : this->state.shapes) {
		const size_t numbPoints = poly.points.size();
		if (numbPoints < 2) {
			continue;
		}
		olc::vf2d start = poly.points[0];
		olc::vf2d end = poly.points[numbPoints - 1];
		view.DrawLineDecal(start, end, olc::WHITE);
		for (size_t idx = 0; idx < numbPoints - 1; idx++) {
			olc::vf2d start = poly.points[idx];
			olc::vf2d end = poly.points[idx + 1];
			view.DrawLineDecal(start, end, olc::WHITE);
		}
	}
	// Ball
	view.DrawCircle(state.ball.position, state.ball.radius, olc::WHITE);
	const auto m = state.ball.radius * 0.6;
	olc::vd2d miniPos = {
		m * cos(state.ball.angularDisplacement),
		m * sin(state.ball.angularDisplacement)
	};
	view.DrawCircle(miniPos + state.ball.position, state.ball.radius * 0.20, olc::WHITE);
	// Goals
	// TODO make the goals look cooler with some animated property that changes over time
	for (const ngon::Goal& goal : state.goals) {
		view.DrawCircle(goal.position, goal.radius, olc::DARK_MAGENTA);
	}
	return true;
}

bool NgonPuzzle::OnUserCreate() {
	// Called once at the start, so create things here

	view.Initialise(GetScreenSize());
	olc::vi2d viewArea(GetScreenSize());
	viewArea.x = -viewArea.x / 2.0;
	viewArea.y = viewArea.y / 2.0;
	view.SetWorldOffset(viewArea);
	view.SetWorldScale({1,-1});
	// TODO help wanted - zoom in. Initial zoom is insufficient.

	editing = new ngon::Editing(this);
	applicationState = editing;
	applicationState->OnStateStart();
	return true;
}

int main()
{
	NgonPuzzle demo;
	if (demo.Construct(640, 480, 2, 2))
		demo.Start();
	return 0;
}

// VS2022, see func overloads? CTRL + Shift + space
